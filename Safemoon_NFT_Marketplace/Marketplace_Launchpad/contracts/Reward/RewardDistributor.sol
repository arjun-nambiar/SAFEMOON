// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract RewardDistributor is Initializable, PausableUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {
    using ECDSA for bytes32;

    uint8 public constant VERSION = 1;

    /** @notice address of the signer */
    address public signer;

    IERC20Upgradeable public rewardToken;

    //Claimed Rewards Per User
    mapping(address => uint256) public claimed;

    event Claim(address user, uint256 claimedRewards);

    event TokenWithdrawnOwner(uint256 amount);

    event UpdateSigner(address signer);

    function rewardDistributor_init(address _rewardToken, address _signer) public initializer {
        rewardToken = IERC20Upgradeable(_rewardToken);
        signer = _signer;
        __Ownable_init();
        __Pausable_init();
    }

    /**
    @notice This function is used to update signer address  
    */
    function setNewSigner(address _signer) external onlyOwner {
        require(signer != address(0), "invalid signer");
        signer = _signer;
        emit UpdateSigner(_signer);
    }

    /**
    @notice This function is used claim rewards for listing NFTs  
    @param earnedRewards total earned rewards
    @param signature The signature sent by the signer  
    */
    function claim(uint256 earnedRewards, bytes memory signature) external whenNotPaused {
        bytes32 message = prepareMessage(msg.sender, earnedRewards);

        require(matchAddressSigner(message, signature), "signer should sign the message");

        uint256 claimedRewards = claimed[msg.sender];

        require(earnedRewards > claimedRewards, "Nothing to claim");

        uint256 toClaim = earnedRewards - claimedRewards;

        require(rewardToken.transfer(msg.sender, toClaim), "Transfer is not successful");

        claimed[msg.sender] += toClaim;

        emit Claim(msg.sender, toClaim);
    }

    /**
    @notice This function is used to withdraw ERC20 from contract  
    */
    function withdrawRewardToken(uint256 _amount) external onlyOwner nonReentrant {
        require(rewardToken.balanceOf(address(this)) > 0, "Nothing to Withdraw");
        require(_amount > 0, "Withdrawing amount should be greater than zero");

        rewardToken.transfer(msg.sender, _amount);

        emit TokenWithdrawnOwner(_amount);
    }

    /**
    @notice Pause distribution
    @dev Only for owner.
     */
    function pauseDistribution() external onlyOwner whenNotPaused {
        _pause();
    }

    /**
    @notice Unpause distribution
    @dev Only for owner.
    */
    function unpauseDistribution() external onlyOwner whenPaused {
        _unpause();
    }

    /**
    @dev This function is used to generate hash message
    @param sender The address who is claiming rewards
    @param _amount ClaimableAmount
    @return hash generated by the function
    */
    function prepareMessage(address sender, uint256 _amount) public view returns (bytes32 hash) {
        hash = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                keccak256(abi.encodePacked(sender, block.chainid, _amount, address(this)))
            )
        );
    }

    /**
    @dev This function is used to verify claim validity using signature  
    @param hash The hash message generated by the function hashMessage  
    @param signature The signature sent in the claim function
    @return boolean value true if the signature is verified else false  
    */
    function matchAddressSigner(bytes32 hash, bytes memory signature) public view returns (bool) {
        return signer == hash.recover(signature);
    }
}
