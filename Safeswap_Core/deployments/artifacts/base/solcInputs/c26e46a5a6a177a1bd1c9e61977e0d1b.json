{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity 0.8.11;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/SafeswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ISafeswapPair.sol\";\nimport \"./SafeswapERC20.sol\";\nimport \"./libraries/Initializable.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ISafeswapFactory.sol\";\nimport \"./interfaces/ISafeswapCallee.sol\";\n\ninterface ISafeswapRouter {\n    function getTokenDeduction(address token, uint256 amount) external view returns (uint256, address);\n}\n\ncontract SafeswapPair is ISafeswapPair, SafeswapERC20, Initializable {\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n    // address public router;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"Safeswap: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier onlyRouter() {\n        require(msg.sender == ISafeswapFactory(factory).router(), \"Safeswap: ONLY_ROUTER\");\n        _;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Safeswap: TRANSFER_FAILED\");\n    }\n\n    function _transferSTPtaxFees(address token, uint256 amount) internal {\n        address router = ISafeswapFactory(factory).router();\n        (uint256 deduction, address to) = ISafeswapRouter(router).getTokenDeduction(token, amount);\n        if (deduction > 0 && to != address(0)) {\n            _safeTransfer(token, to, deduction);\n        }\n    }\n\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external initializer {\n        factory = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n        _SafeswapERC20_init_();\n        unlocked = 1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"Safeswap: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    function _takeFee(\n        address token,\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) private returns (uint256 _fee) {\n        require(token == token0 || token == token1, \"Safeswap: INVALID_TOKEN\");\n        address feeTo = ISafeswapFactory(factory).feeTo();\n        uint256 _totalSupply = totalSupply;\n\n        bool feeOn = feeTo != address(0);\n        uint256 amountOutWithoutFee = (amountOut * 10000) / 9975;\n        //uint FeeSTP = amountOutWithoutFee.mul(100) / 10000;\n        uint256 burnFee = (amountOutWithoutFee * 3) / 10000;\n        uint256 supportFee = (amountOutWithoutFee * 5) / 10000;\n\n        uint256 numerator = reserveIn * burnFee;\n        uint256 denominator = reserveOut - burnFee;\n        uint256 amountIn = numerator / denominator;\n\n        uint256 liquidity = Math.min((amountIn * _totalSupply) / reserveIn, (burnFee * _totalSupply) / reserveOut);\n        _mint(0x000000000000000000000000000000000000dEaD, liquidity);\n        _fee = burnFee;\n\n        if (feeOn) {\n            numerator = reserveIn * supportFee;\n            denominator = reserveOut - supportFee;\n            amountIn = numerator / denominator;\n\n            liquidity = Math.min((amountIn * _totalSupply) / reserveIn, (supportFee * _totalSupply) / reserveOut);\n            _mint(feeTo, liquidity);\n            _fee = _fee + supportFee;\n            //_safeTransfer(token0, 0x6B6003F0F3E7C9F096813b5c4F0F6DA9FD8D24Ba, FeeSTP);\n        }\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = ISafeswapFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply * (rootK - rootKLast);\n                    uint256 denominator = rootK * 3 + rootKLast;\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        require(ISafeswapFactory(factory).isBlacklistedStatus(to) == false, \"Address is blacklisted\");\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"Safeswap: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        require(ISafeswapFactory(factory).isBlacklistedStatus(to) == false, \"Address is blacklisted\");\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"Safeswap: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock onlyRouter {\n        require(ISafeswapFactory(factory).isBlacklistedStatus(to) == false, \"Address is blacklisted\");\n        require(amount0Out > 0 || amount1Out > 0, \"Safeswap: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"Safeswap: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"Safeswap: INVALID_TO\");\n            if (amount0Out > 0) {\n                // _takeFee(_token0, amount0Out, _reserve1, reserve0);\n                _safeTransfer(_token0, to, amount0Out);\n            } // optimistically transfer tokens\n            if (amount1Out > 0) {\n                // _takeFee(_token1, amount1Out, _reserve0, _reserve1);\n                _safeTransfer(_token1, to, amount1Out);\n            } // optimistically transfer tokens\n            if (data.length > 0) ISafeswapCallee(to).safeswapCall(msg.sender, amount0Out, amount1Out, data);\n            if (amount0Out > 0) {\n                _transferSTPtaxFees(token0, amount0Out);\n            }\n            if (amount1Out > 0) {\n                _transferSTPtaxFees(token1, amount1Out);\n            }\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"Safeswap: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * 2;\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * 2;\n            require(balance0Adjusted * balance1Adjusted >= uint256(_reserve0) * _reserve1 * (1000**2), \"Safeswap: K\");\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "contracts/interfaces/ISafeswapPair.sol": {
      "content": "pragma solidity 0.8.11;\n\ninterface ISafeswapPair {\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/SafeswapERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./interfaces/ISafeswapERC20.sol\";\ncontract SafeswapERC20 is ISafeswapERC20 {\n\n    string public constant name = \"Safeswap LPs\";\n    string public constant symbol = \"SFS-LP\";\n    uint8 public constant decimals = 18;\n\n    bytes32 private __avoid_collision_storage; // to avoid collisions storage\n    \n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    function _SafeswapERC20_init_() internal {\n        uint256 chainId = block.chainid;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply + value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from] - value;\n        totalSupply = totalSupply - value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from] - value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"Safeswap: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"Safeswap: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/libraries/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity 0.8.11;\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\ncontract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { cs := extcodesize(self) }\n        return cs == 0;\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "pragma solidity 0.8.11;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity 0.8.11;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/interfaces/ISafeswapFactory.sol": {
      "content": "pragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\ninterface ISafeswapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 length);\n\n    function feeTo() external view returns (address);\n\n    function router() external view returns (address);\n    \n    function implementation() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function isBlacklistedStatus(address account) external view returns (bool);\n\n    function approvePartnerStatus(address account) external view returns (bool);\n\n    function isBlacklistedToken(address account) external view returns (bool);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n//    function getFeeConfig() external view returns (FeeConfig memory);\n//\n//    function getTotalFee() external view returns (uint256, uint256);\n//\n//    struct FeeConfig {\n//        address feeTo;\n//        address buyBackWallet;\n//        uint256 companyFeePercent;\n//        uint256 buyBackFeePercent;\n//        uint256 lpFeePercent;\n//        uint256 precision;\n//    }\n}\n"
    },
    "contracts/interfaces/ISafeswapCallee.sol": {
      "content": "pragma solidity 0.8.11;\n\ninterface ISafeswapCallee {\n    function safeswapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/ISafeswapERC20.sol": {
      "content": "pragma solidity 0.8.11;\n\ninterface ISafeswapERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/SafeswapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ISafeswapFactory.sol\";\nimport \"./SafeswapPair.sol\";\nimport \"./libraries/proxy/OptimizedTransparentUpgradeableProxy.sol\";\nimport \"./libraries/Initializable.sol\";\n\ncontract SafeswapFactory is ISafeswapFactory, Initializable {\n    bytes32 public constant INIT_CODE_PAIR_HASH =\n        keccak256(abi.encodePacked(type(OptimizedTransparentUpgradeableProxy).creationCode));\n\n    address public feeTo;\n    address public feeToSetter;\n    address public router;\n    address public admin;\n\n    mapping(address => bool) public isBlacklistedStatus;\n    mapping(address => bool) public approvePartnerStatus;\n    mapping(address => bool) public isBlacklistedToken;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    address public implementation;\n\n    modifier onlyOwner() {\n        require(admin == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function initialize(address _feeToSetter, address _feeTo) external initializer {\n        feeToSetter = _feeToSetter;\n        feeTo = _feeTo;\n        admin = msg.sender;\n    }\n\n    function setImplementation(address _impl) external onlyOwner {\n        require(_impl != address(0), \"Not allow zero address\");\n        implementation = _impl;\n    }\n\n    function deployImplementation() external onlyOwner {\n        implementation = address(new SafeswapPair());\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external returns (address pair) {\n        require(implementation != address(0), \"Please set implementation\");\n        require((isBlacklistedToken[tokenA] == false), \"Cannot create with tokenA\");\n        require((isBlacklistedToken[tokenB] == false), \"Cannot create with tokenB\");\n        require((approvePartnerStatus[to] == true), \"Not approved the partner\");\n        require((approvePartnerStatus[msg.sender] == true), \"Not approved the partner\");\n\n        require(tokenA != tokenB, \"Safeswap: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Safeswap: ZERO_ADDRESS\");\n        require(getPair[token0][token1] == address(0), \"Safeswap: PAIR_EXISTS\"); // single check is sufficient\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        OptimizedTransparentUpgradeableProxy pairProxy = new OptimizedTransparentUpgradeableProxy{ salt: salt }();\n        pairProxy._OptimizedTransparentUpgradeableProxy_init_(\n            address(this),\n            address(0x000000000000000000000000000000000000dEaD),\n            hex\"\"\n        );\n        pair = address(pairProxy);\n        ISafeswapPair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setRouter(address _router) public {\n        require(msg.sender == admin, \"NOT AUTHORIZED\");\n        router = _router;\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"Safeswap: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"Safeswap: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n\n    function blacklistAddress(address account) external onlyOwner {\n        require((isBlacklistedStatus[account] == false), \"Already Blacklisted\");\n        isBlacklistedStatus[account] = true;\n    }\n\n    function unBlacklistAddress(address account) external onlyOwner {\n        require((isBlacklistedStatus[account] == true), \"Already Not Blacklisted\");\n        isBlacklistedStatus[account] = false;\n    }\n\n    function blacklistTokenAddress(address token) external onlyOwner {\n        require((isBlacklistedToken[token] == false), \"Already Blacklisted\");\n        isBlacklistedToken[token] = true;\n    }\n\n    function whitelistTokenAddress(address token) external onlyOwner {\n        require((isBlacklistedToken[token] == true), \"Already Whitelisted\");\n        isBlacklistedToken[token] = false;\n    }\n\n    function approveLiquidityPartner(address account) external onlyOwner {\n        require((approvePartnerStatus[account] == false), \"Already approved\");\n        approvePartnerStatus[account] = true;\n    }\n\n    function unApproveLiquidityPartner(address account) external onlyOwner {\n        require((approvePartnerStatus[account] == true), \"Not approved yet\");\n        approvePartnerStatus[account] = false;\n    }\n}\n"
    },
    "contracts/libraries/proxy/OptimizedTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./UpgradeableProxy.sol\";\nimport \"../../libraries/Initializable.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative inerface of your proxy.\n */\ncontract OptimizedTransparentUpgradeableProxy is UpgradeableProxy, Initializable {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    function _OptimizedTransparentUpgradeableProxy_init_(\n        address factory,\n        address initialAdmin,\n        bytes memory _data\n    ) external initializer {\n        _UpgradeableProxy_init_(factory, _data);\n\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        bytes32 slot = _ADMIN_SLOT;\n\n        // still store it to work with EIP-1967\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, initialAdmin)\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newFactory) external ifAdmin {\n        _upgradeTo(newFactory);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newFactory, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newFactory);\n        address newImplementation = _implementation();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/libraries/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./Proxy.sol\";\nimport \"../../interfaces/ISafeswapFactory.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * factory address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * factory behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial factory specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    function _UpgradeableProxy_init_(address _factory, bytes memory _data) internal {\n        assert(_FACTORY_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.factoryfactory\")) - 1));\n        _setFactory(_factory);\n        if (_data.length > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            address impl = ISafeswapFactory(_factory).implementation();\n            (bool success, ) = impl.delegatecall(_data);\n            require(success);\n        }\n    }\n\n    /**\n     * @dev Emitted when the factory is upgraded.\n     */\n    event Upgraded(address indexed factory);\n\n    /**\n     * @dev Storage slot with the address of the current factory.\n     * This is the keccak-256 hash of \"eip1967.proxy.factoryfactory\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _FACTORY_SLOT = 0xb2101b231486a8a17a16c101f8dde1145d21799358462f57035a227f25614da3;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view override returns (address impl) {\n        address factory;\n        bytes32 slot = _FACTORY_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            factory := sload(slot)\n        }\n\n        // call to Factory and get Impl\n        impl = ISafeswapFactory(factory).implementation();\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newFactory) internal {\n        _setFactory(newFactory);\n        emit Upgraded(newFactory);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setFactory(address newFactory) private {\n        require(Address.isContract(newFactory), \"UpgradeableProxy: new factory is not a contract\");\n\n        bytes32 slot = _FACTORY_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newFactory)\n        }\n    }\n}\n"
    },
    "contracts/libraries/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./Greater.sol\";\nimport \"../libraries/proxy/OptimizedTransparentUpgradeableProxy.sol\";\n\ncontract MockFactory {\n    address public implementation;\n\n    function setImplementation(address _impl) external {\n        require(_impl != address(0), \"Not allow zero address\");\n        implementation = _impl;\n    }\n\n    function deployImplementation() external {\n        implementation = address(new Greater());\n    }\n\n    function createContract() external returns (address deployedAddr) {\n        require(implementation != address(0), \"Please set implementation\");\n        OptimizedTransparentUpgradeableProxy pairProxy = new OptimizedTransparentUpgradeableProxy();\n        pairProxy._OptimizedTransparentUpgradeableProxy_init_(address(this), address(0), hex\"\");\n        deployedAddr = address(pairProxy);\n    }\n}\n"
    },
    "contracts/mocks/Greater.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ncontract Greater {\n    uint256 public __nothing;\n    uint256 public count;\n    mapping(uint256 => uint256) public balance;\n\n    function increase() external {\n        count++;\n    }\n\n    function decrease() external {\n        count--;\n    }\n\n    function setBalance(uint256 _id, uint256 _balance) external {\n        balance[_id] = _balance;\n    }\n\n    function doSomethingWithCount() external {\n        count += 5;\n    }\n}\n\ncontract NewGreater {\n    uint256 public __nothing;\n    uint256 public count;\n    mapping(uint256 => uint256) public balance;\n\n    function increase() external {\n        count++;\n    }\n\n    function decrease() external {\n        count--;\n    }\n\n    function setBalance(uint256 _id, uint256 _balance) external {\n        balance[_id] = _balance;\n    }\n\n    function doSomethingWithCount() external {\n        count += 10;\n    }\n}\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport '../SafeswapERC20.sol';\n\ncontract ERC20 is SafeswapERC20 {\n    constructor(uint _totalSupply) public {\n        _mint(msg.sender, _totalSupply);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}